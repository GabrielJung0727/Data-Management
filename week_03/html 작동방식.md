| 단계 | 설명 |
|------|----------------------------------------------------------------|
| **1. 사용자가 웹페이지 요청** | 사용자가 브라우저 주소창에 URL 입력 또는 링크 클릭 시 요청 발생 |
| | - HTTP/HTTPS 프로토콜을 사용하여 요청 |
| | - GET, POST 등의 HTTP 메서드 사용 |
| | - DNS가 도메인 네임을 해당 서버의 IP 주소로 변환 |
| **2. 서버와 통신하여 HTML 문서 다운로드** | 브라우저가 DNS를 통해 서버 IP 확인 후 웹 서버와 연결 |
| | - 웹 서버(Apache, Nginx 등)가 요청을 처리하고 HTML 반환 |
| | - 동적 웹페이지(PHP, Node.js, Python 등)는 서버에서 HTML 생성 후 응답 |
| | - CDN(Content Delivery Network)이 캐싱된 HTML을 제공할 수도 있음 |
| **3. 브라우저가 HTML을 파싱 (Parsing)** | 브라우저가 HTML을 한 줄씩 읽어 DOM 트리 생성 |
| | - DOM(Document Object Model) 트리 생성 |
| | - `<script>` 태그를 만나면 HTML 파싱이 중단되고 스크립트 실행 |
| **4. CSS 요청 및 스타일 적용** | HTML 파싱 중 `<link>` 태그를 만나면 CSS 다운로드 및 적용 |
| | - CSS 파일을 파싱하여 CSSOM(CSS Object Model) 트리 생성 |
| | - DOM 트리와 CSSOM 트리를 결합하여 Render Tree 구성 |
| **5. JavaScript 실행** | HTML 파싱 중 `<script>` 태그를 만나면 스크립트 실행 |
| | - JavaScript가 DOM을 조작할 수 있어 HTML 파싱이 중단될 수 있음 |
| | - `async`: 다운로드 후 즉시 실행, `defer`: HTML 파싱 완료 후 실행 |
| **6. 레이아웃(배치, Layout) 단계** | Render Tree를 기반으로 각 요소의 크기와 위치 계산 |
| | - 브라우저 뷰포트 크기에 따라 요소 위치 결정 |
| | - 상대 크기(%, em 등)는 부모 요소 기준으로 계산 |
| **7. 페인팅(Painting) 단계** | 화면에 픽셀을 그리는 단계 |
| | - 계산된 위치와 스타일을 GPU에 전달하여 렌더링 |
| | - 색상, 배경, 테두리, 그림자 등의 스타일 적용 |
| **8. 합성(Compositing) 및 화면 출력** | 모든 요소를 최적화하여 GPU가 레이어별로 그린 후 화면 출력 |
| | - CSS 애니메이션, WebGL, 3D 변환 등 효과 적용 |
| | - 스크롤 시 최적화된 부분만 다시 그림 (Repaint) |
